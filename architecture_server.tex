\section{Architecture Server}

\subsection{Redis Cache}


\subsection{Server Architecture}

The architecture consists of the following components: Client, Middleware server, Local Cache, Metadata Server and Content Server(Content Distributors). The Architecture overview is showed on figure \ref{fig:arch_overview}. 

The client sends requests to the middleware server. The middleware server handles client requests and sends back appropriate responses. The response can be one of two types: Configurational or Data demand. If response is configurational the server redirects it to the Metadata server, otherwise it redirects it to the Content server. The middleware supports local cache and caches every response that is not assosiated with user session. The problem is that the middleware server is tightly coupled with content server. As a result, for every content distributor, new middleware is deployed. It is not very optimal approach.

The client is a web application developed using javascript, html, css frameworks and Model View Controller pattern. It communicates with middleware server through REST services. In order to render single page, several HTTP requests must be done. If client needs to render complicated page, multiple HTTP requests will decrease the performance. The better approach will be aggregate corresponding requests into one and send it to the middleware server.    

The components description:

\begin{itemize}
	\item Client can be Android application, iOS application, HTML/CSS application or any other application that have communication througth TCP/IP protocol.
    \item Middleware is a data aggregation framework. It gathers and manages data from metadata server and content servers.
    \item Local Cache is represented by a Redis database. It is key-value in memory database[reference]. In order not to make additional requests to the outer servers, the middleware caches the responses for some time in the local database.
    \item Metadata server is the outer server that stores information about content distributors, sessions, and assets[describe what is asset].
    \item Content servers(content distributors) are customer APIs that provide access to the content.

\end{itemize}

The client makes requests to the middleware. The middleware picks the appropriate content from content distributors and sends it back to the client. On the first request, the middleware connects to the metada server. The metadata server assignes a new session to the client and sends it back to the middleware. Using this session, the middleware retrieves the resource locator from the metadata server. The middleware stores the response from the metadata server in the local database. Using the resourse locator, the middleware requests the appropriate content from the content server and sends back to the client.

In order to improve the performance and avoid additional requests to the content distributors, the middleware server has a local in memory database that stores content and metadata for some time. This technique helps to decrease traffic between content servers and the client and avoid delays in highly loaded hours(mb change?).  

\subsection{Middleware server architecture}

The middleware server is written on server side javascript language, using asynchronous server Node.js. The server developed using Model View Controller (MVC) pattern and communicates with other components through REST services. As a result, the server components are loosely coupled with each other, that gives great flexibility in changing and replacing components and simplifies testing. 

The middleware consists of next components: Controllers, Managers, Services, Configuration and Data Model Object builders. 

The controllers recieve requests, validate user data and redirect them to assigned manager. The manager checks the local cache, if the request is new, or the cache data is stale, the manager invokes assigned services. Every client has UUID,(unique user identifier). When the client makes first configurational request, the server requests new session key from the Metadata Server using users UUID. The session key is represented by a unique session identifier that has expiration date. This identifier is transferred with every configurational request to the Metadata server. The configurational requests are user actions, user setting, metadata health check, etc. When the client makes the data demand request, the manager invokes content services, that redirect request to the assigned content server. The response then is stored in the cache, translated into Data Model object(DMO) and transferred back to the client in JSON format. The builders are in charge for translating JSON data into Persistent Data Model objects. For every DMO there is an assigned manager and service. As an example, if the content server responses with video object, there will be VideoManager and VideoService components.   

The client layer and middleware layer are loosely coupled and communicate with each other through REST services. It gives application great flexibility.

As mentioned earlier, the drawback of this architecture are specific DMO objects. The middleware server serves as a data redirector and data aggregator, and should be general about what data coming through him. The next section will present the View Model Objects(VMO) and how it can improve performance.

% Client
% Controller:
% 	Recieve requests from clients
% Managers:
% 	Manages cache layer,
% 	Calls appropriate services on cache miss,
% 	Translates data into Persistent Data Model Objects.
% Services:
% 	1. AppGrid services(Metadata server):
% 		Manages AppGrid sessions
% 		Configuration requests
% 		Log requests(user actions)
% 		User Settings
% 	2. OVP services (Content server)
% 		Manages individual content
% 		Example: User authentification, content entities

\begin{figure}[h]
\begin{center}

	\resizebox{1.0\textwidth}{0.7\textwidth} {

	\begin{sequencediagram}
	\newthread[white]{cl}{Client}
	\newinst[1.7]{cntr}{Controller}
	\newinst[1.3]{mgr}{Manager}
	\newinst[1.3]{lc}{Local Cahce}
	\newinst[1.3]{serv}{Service}
	\newinst[1.3]{es}{External server}

	\begin{call}{cl}{Configuration request}{cntr}{Response}

		\begin{call}{cntr}{Invoke configuation manager}{mgr}{Response Data}
			\begin{call}{mgr}{Check Session key}{lc}{Cache Response}\end{call}
			\begin{sdblock}{alt}{if session key not in cache}
				\begin{call}{mgr}{Get session key using UUID}{serv}{Session key}
					\begin{call}{serv}{Session key request}{es}{Server response}
					\end{call}
				\end{call}
			\end{sdblock}
			\begin{call}{mgr}{Call data service}{serv}{JSON Data}
				\begin{call}{serv}{Call REST API}{es}{JSON data}
				\end{call}
			\end{call}
			\begin{call}{mgr}{Cache response}{lc}{}
			\end{call}
			\begin{call}{mgr}{Make DMO}{mgr}{DMO}\end{call}
		\end{call}

	\end{call}

	\end{sequencediagram}
	}

\end{center}
\caption{Sequence Diagram}
\label{fig:arch_uml}
\end{figure}

\begin{figure}[h]
\begin{center}

	\begin{tikzpicture}[
	  font=\sffamily,
	  every matrix/.style={ampersand replacement=\&,column sep=1cm,row sep=2cm},
	  client/.style={draw,thick,ellipse,fill=yellow!20,inner sep=.3cm},
	  middleware/.style={draw,very thick,shape=rectangle,inner sep=.3cm},
	  source/.style={draw,thick,rounded corners,fill=yellow!20,inner sep=.3cm},
	  sink/.style={source,fill=green!20},
	  every node/.style={align=center}]

	  \tikzstyle{state} = [draw, very thick, fill=white, rectangle, minimum height=3em, minimum width=7em, node distance=8em, font={\sffamily\bfseries}]
	  \tikzstyle{stateEdgePortion} = [black,thick];
	  \tikzstyle{stateEdge} = [stateEdgePortion,->];
	  \tikzstyle{edgeLabel} = [pos=0.5, text centered, font={\sffamily\small}];


	  % Position the nodes using a matrix layout
	  \matrix{
	    \& \node[client] (client) {Clients}; \& \\

	    \& \node[middleware] (middleware) {Middleware}; \& \\

	    \node[sink] (mtserver) {Metadata Server};
	      \& \& \node[sink] (ovp) {OVP}; \\
	  };

	  \draw ($(client.south) + (-.5em,0)$) 
	      edge[stateEdge] node[edgeLabel,xshift=-1em, yshift=-1em]{\emph{Request}} 
	      ($(middleware.north) + (-.5em,0)$);
	  \draw ($(middleware.north) + (.5em,0)$) 
	      edge[stateEdge] node[edgeLabel,xshift=4em]{\emph{Data}} 
	      ($(client.south) + (.5em,0)$);


	  \draw ($(middleware.west) + (0,.5em)$) 
	      edge[stateEdge] node[edgeLabel,xshift=-4em, yshift=-1em]{\emph{Request}} 
	      ($(mtserver.north) + (-.5em,0)$);
	  \draw ($(mtserver.north) + (.5em,0)$) 
	      edge[stateEdge] node[edgeLabel,xshift=2em]{\emph{Session ID}} 
	      ($(middleware.west) + (0,-.5em)$);


	  \draw ($(middleware.east) + (0,.5em)$) 
	      edge[stateEdge] node[edgeLabel,xshift=-2em, yshift=-1em]{\emph{Request}} 
	      ($(ovp.north) + (.5em,0)$);
	  \draw ($(ovp.north) + (-.5em,0)$) 
	      edge[stateEdge] node[edgeLabel,xshift=2em]{\emph{Data Resp}} 
	      ($(middleware.east) + (0,-.5em)$);


	\end{tikzpicture}

\end{center}
\caption{Architecture overview}
\label{fig:arch_overview}
\end{figure}


\begin{figure}[h]
\begin{center}

	\resizebox{1.0\textwidth}{0.8\textwidth} {

	\begin{sequencediagram}
	\newthread[white]{cl}{Client}
	\newinst[1.7]{mw}{Middleware}
	\newinst{lc}{Local Cache}
	\newinst[1.9]{ms}{Metadata Server}
	\newinst[1.3]{cs}{Content Server}

	\begin{call}{cl}{First request}{mw}{Response}

		\begin{call}{mw}{Create new session}{ms}{Session ID}
		\end{call}

		\begin{call}{mw}{Cache Session}{lc}{}
		\end{call}

		\begin{call}{mw}{Get content locator}{ms}{URL}
		\end{call}

		\begin{call}{mw}{Cache Locator}{lc}{}
		\end{call}

	\end{call}

	\begin{call}{cl}{GET Request}{mw}{GET Response}
		
		\begin{call}{mw}{Check Local Cache}{lc}{}
		\end{call}

		\begin{sdblock}{alt}{if data in cache}
			\begin{call}{mw}{Send response to Client}{cl}{}
			\end{call}
			\begin{sdblock}{else}{}
				\begin{call}{mw}{Request Content}{cs}{Response}
				\end{call}
				\begin{call}{mw}{Cache content}{lc}{}
				\end{call}
			\end{sdblock}
		\end{sdblock}


	\end{call}

	\end{sequencediagram}
	}

\end{center}
\caption{Sequence Diagram}
\label{fig:arch_uml}
\end{figure}

\newpage
